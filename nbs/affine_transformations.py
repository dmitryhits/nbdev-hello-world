# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/affine_transformations.ipynb (unless otherwise specified).

__all__ = None

# Cell

# Cell
# --------------------------------------------------------
#       methods to apply 2D affine transformations
# Cell
# created on April 5th 2022 by M. Reichmann (remichae@phys.ethz.ch)
# --------------------------------------------------------
from numpy import array, append, sin, cos, ones
from numpy.linalg import inv


# Cell
def scale_matrix(sx=1, sy=None):
    return array([[sx, 0, 0], [0, sx if sy is None else sy, 0], [0, 0, 1]])


# Cell
def transition_matrix(ox=0, oy=0):
    return array([[1, 0, ox], [0, 1, oy], [0, 0, 1]])


# Cell
def rotation_matrix(rx=0, ry=None):
    x = [cos(rx), -sin(rx), 0] if ry is None else append(rx[:2], 0)
    y = [sin(rx), cos(rx), 0] if ry is None else append(ry[:2], 0)
    return array([x, y, [0, 0, 1]])


# Cell
def matrix_order(order):
    d = {'s': 0, 't': 1, 'r': 2}
    return array([d[i] for i in order])


# Cell
def multiply(m0, m1, m2):
    """returns: M0 * M1 * M2 """
    return m0 @ m1 @ m2


# Cell
def matrix(sx=1, sy=1, ox=0, oy=0, rx=0, ry=None, order='srt'):
    s, t, r = scale_matrix(sx, sy), transition_matrix(ox, oy), rotation_matrix(rx, ry)
    return multiply(*array([s, t, r])[matrix_order(order)])


# Cell
def transform(x, y, sx=1, sy=1, ox=0, oy=0, rx=0, ry=None, order='srt', invert=False):
    m = matrix(sx, sy, ox, oy, rx, ry, order)
    return ((inv(m) if invert else m) @ array([x, y, ones(x.size, 'i')]))[:2]


# Cell
def m_transform(m, x, y, invert=False):
    return ((inv(m) if invert else m) @ array([x, y, ones(x.size, 'i')]))[:2]
